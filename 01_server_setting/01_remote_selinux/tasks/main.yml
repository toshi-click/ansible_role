# ===================
# getenforeにてdisableが帰ってきた場合は再起動しないため確認
# regiter: selinux_resultはshellで表すと
# selinux_result = `getenforece`
# と同様
# registerが変数名でshellが実行したコマンド
# ===================
# SELinuxのDisable状態の確認
- name: Confirmation of Disable status of SELinux
  shell: "getenforce"
  register: selinux_result

# ===================
# (shellモジュール:)2秒スリープしたのち再起動する
#
# (async/pollモジュール:)「async=終了まで待つ時間」、「poll=終了までチェックする間隔」
# asyncで指定しpollでのチェック間隔で終了チェックをし続け、終わらなければエラーとなる
# 以下の場合、poll=0を設定しており、ポーリングは行われず且つasyncの時間を待たずに完全に非同期処理となり
# 次のタスクを実行する
#
# (whenモジュール:)で上記で変数指定したselinux_resultのstdout(標準出力結果)
# がdisable以外の場合のみ再起動する(whenはif文と同様)
#
# ignore_errorsは全てのサーバで【 shell: sleep 2 && shutdown -r now "サーバ再起動"】が失敗しても処理を終了せず
# 次のタスクを実行するが、今回のようなshutdownは特別でSSH接続自体が出来なくなる為、ignore_errorsは効果が出ない
#
# 待たずに次のタスクを行う
# ===================
# SELinuxのDisableでない場合サーバ再起動
- name: If SELinux is not Disable Server restart
  shell: sleep 2 && shutdown -r now "reboot now"
  async: 1
  poll: 0
  when: selinux_result.stdout != "Disabled"
# ignore_errors: true

# ===================
# 上記のタスクはasyncモジュールを使用しているので完了前に当該タスクが呼ばれる事になる
# wait_for
# delayの値の間待機したのち
# hostの
# portに接続できるまで1秒(デフォルト)間隔で接続しに行く
# 以下の設定では
# inventory_hostname(Ansibleが設定しているサーバ)に対して20秒待ってから
# 22ポートに対して接続を300秒間(デフォルト)待ち続ける設定になる
# ただし、当該タスクも条件(whenモジュール)に指定の
# selinux_resultのstdout(標準出力結果)
# がdisable以外の場合のみ再起動する(whenはif文と同様)
# ===================
# SELinuxのDisableでない場合サーバ再起動待ち
- name: When not SELinux Disable Waiting for server reboot
  local_action: wait_for host={{ inventory_hostname }} port=22 delay=10
  when: selinux_result.stdout != "Disabled"
